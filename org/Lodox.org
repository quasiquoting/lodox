#+STARTUP: showall
#+OPTIONS: toc:t
#+TITLE:    Lodox
#+SUBTITLE: Like Codox for LFE.
#+DATE:     2015-10-31
#+AUTHOR:   Eric Bailey
#+EMAIL:    quasiquoting@gmail.com
#+LANGUAGE: en
#+CREATOR:  Emacs 24.5.1 (Org mode 8.3.2)

#+NAME: lodox-version
#+BEGIN_SRC sh :exports none
cat VERSION
#+END_SRC

* Literate Programming Setup
Set [[http://orgmode.org/manual/Code-evaluation-security.html#index-org_002dconfirm_002dbabel_002devaluate-2148][~org-confirm-babel-evaluate~]] to a ~lambda~ expression that takes the
~lang~-uage and ~body~ of a code block and returns ~nil~ if ~lang~ is
=​"emacs-lisp"​= or =​"sh"​=, otherwise ~t~.
#+NAME: auto-eval-elisp
#+BEGIN_SRC emacs-lisp :results silent
(setq-local org-confirm-babel-evaluate
            (lambda (lang body)
              (not (or (string= lang "emacs-lisp")
                       (string= lang "sh")))))
#+END_SRC

Define an Emacs Lisp code block called =generated= that takes a ~lang~-uage
(default: ~​"lfe"​~) and produces a commented notice that source code in this
project is generated by this Org file.
#+NAME: generated
#+BEGIN_SRC emacs-lisp :var lang="lfe"
(let ((comment (cond
                ((string= lang "erlang")        "%%%")
                ((member lang '("conf" "yaml")) "###")
                (t                              ";;;")))
      (line    (make-string 67 ?=))
      (warning "This file was generated by Org. Do not edit it directly.")
      (how-to  "Instead, edit Lodox.org in Emacs and call org-babel-tangle."))
  (format "%s%s\n%s %s\n%s %s\n%s%s\n\n"
          comment line
          comment warning
          comment how-to
          comment line))
#+END_SRC

For example, ~<<generated("lfe")>>~ produces:
#+BEGIN_SRC text :noweb yes
<<generated("lfe")>>
#+END_SRC

Tangle the literate Lodox source.
#+BEGIN_SRC emacs-lisp :exports code :results silent
(declare-function org-babel-tangle "ob-tangle")

(defconst lodox-literate-source (buffer-file-name))

(defun quasiquoting/tangle-literate-lodox-source ()
  "Upon saving the Lodox README.org, tangle it."
  (when (file-equal-p buffer-file-name lodox-literate-source)
    (org-babel-tangle-file "LICENSE.org")
    (org-babel-tangle)))

;; (add-hook 'after-save-hook 'quasiquoting/tangle-literate-lodox-source)
#+END_SRC
N.B. The ~after-save-hook~ is disabled for now.

* Git config
  :PROPERTIES:
  :noweb:    yes
  :padline:  no
  :END:
** .gitignore
   :PROPERTIES:
   :tangle:   ../.gitignore
   :END:
#+BEGIN_SRC conf :exports none
## -*- conf -*-
<<generated("conf")>>
#+END_SRC
#+BEGIN_SRC conf
.DS_Store
_*
*.beam
ebin
erl_crash.dump
#+END_SRC

** Submodules
   :PROPERTIES:
   :tangle:   ../.gitmodules
   :END:
#+BEGIN_SRC conf :exports none
<<generated("conf")>>
#+END_SRC
#+BEGIN_SRC conf
[submodule "doc"]
path   = doc
url    = git@github.com:quasiquoting/lodox.git
branch = gh-pages
#+END_SRC

* Application Resource File
  :PROPERTIES:
  :tangle:   ../src/lodox.app.src
  :noweb:    yes
  :END:
#+BEGIN_SRC erlang :exports none
<<generated("erlang")>>
#+END_SRC
#+NAME: lodox-github
#+BEGIN_SRC emacs-lisp :exports none :tangle no
"github.com/quasiquoting/lodox"
#+END_SRC
#+BEGIN_SRC erlang :padline yes :tangle ../src/lodox.app.src
{application,    'lodox',
 [{description,  "The LFE rebar3 Lodox plugin"},
  {vsn,          "<<lodox-version()>>"},
  {modules,      [lodox,
                  'lodox-html-writer', 'lodox-p', 'lodox-parse', 'lodox-util',
                  'unit-lodox-tests']},
  {registered,   []},
  {applications, [kernel, stdlib]},
  {env,          []},
  {links,
   [{"Homepage", "https://<<lodox-github()>>"},
    {"Documentation", "http://quasiquoting.org/lodox"}]}]}.
#+END_SRC

* Rebar3 Configuration
  :PROPERTIES:
  :exports:  none
  :tangle:   no
  :noweb:    yes
  :padline:  no
  :END:
#+BEGIN_SRC erlang :tangle ../rebar.config
<<generated("erlang")>>
#+END_SRC
#+BEGIN_SRC erlang :exports code :tangle ../rebar.config
<<eunit_compile_opts>>

<<plugins>>

{deps,
 [<<lfe>>,
  <<clj>>,
  <<exemplar>>,
  <<markdown>>,
  <<levaindoc>>]}.

<<lodox-config>>

<<profiles>>
#+END_SRC

** EUnit Compile Options
TODO: Describe =rebar.config= here.
#+NAME: eunit_compile_opts
#+BEGIN_SRC erlang :exports code
{eunit_compile_opts, [{src_dirs, ["test"]}]}.
#+END_SRC

** Plugins
TODO: Describe this and the mess wrt =~/.config/rebar3/rebar.config=
#+NAME: plugins
#+BEGIN_SRC erlang :exports code
{plugins,
 [{'lfe-compile',
   {git, "git://github.com/lfe-rebar3/compile.git",
    {tag, "0.3.0"}}}]}.

{provider_hooks, [{pre, [{compile, {lfe, compile}}]}]}.
#+END_SRC

** Dependencies
*** Project-wide
**** lfe
The first and foremost dependency is, of course, [[https://github.com/rvirding/lfe][LFE]] itself.
Use the latest version, which as of this writing, is:
#+NAME: lfe-version
: 1.0

#+NAME: lfe
#+BEGIN_SRC erlang
{lfe,      {git, "git://github.com/rvirding/lfe.git",  {tag, "<<lfe-version()>>"}}}
#+END_SRC

**** clj
For the Clojure-inspired threading macros, use [[https://github.com/lfex/clj][clj]].
#+NAME: clj-version
: 0.4.0

#+NAME: clj
#+BEGIN_SRC erlang
{clj,      {git, "git://github.com/lfex/clj.git",      {tag, "<<clj-version()>>"}}}
#+END_SRC

**** exemplar
To handle HTML rendering, use [[https://github.com/lfex/exemplar][exemplar]].
#+NAME: exemplar-version
: 0.3.0

#+NAME: exemplar
#+BEGIN_SRC erlang
{exemplar, {git, "git://github.com/lfex/exemplar.git", {tag, "<<exemplar-version()>>"}}}
#+END_SRC

**** erlmarkdown
For markdown: [[https://github.com/erlware/erlmarkdown][erlmarkdown]].
#+NAME: markdown
#+BEGIN_SRC erlang
{markdown,
 {git, "git://github.com/erlware/erlmarkdown.git",
  {branch, "master"}}}
#+END_SRC

**** levaindoc
[[https://github.com/quasiquoting/levaindoc][levaindoc]], LFE wrapper for [[http://pandoc.org][Pandoc]].
#+NAME: levaindoc
#+BEGIN_SRC erlang
{levaindoc,
 {git, "git://github.com/quasiquoting/levaindoc.git",
  {tag, "0.3.2"}}}
#+END_SRC

*** Test profile
**** ltest
To make writing [[http://www.erlang.org/doc/apps/eunit/chapter.html][EUnit]] tests easier, use [[https://github.com/lfex/ltest][ltest]].
#+NAME: ltest-version
: 0.8.0

#+NAME: ltest
#+BEGIN_SRC erlang
{ltest, {git, "git://github.com/lfex/ltest.git", {tag, "<<ltest-version()>>"}}}
#+END_SRC

**** proper
For property-based testing, use [[http://proper.softlab.ntua.gr][PropEr]].
#+NAME: proper
#+BEGIN_SRC erlang
{proper,
 {git, "git://github.com/manopapad/proper.git",
  {branch, "master"}}}
#+END_SRC

** Lodox Config
TODO: describe Lodox config here and document it in the README.

#+NAME: lodox-config
#+BEGIN_SRC erlang :exports code
{lodox,
 [{apps,
   [{lodox,
     [{'source-uri',
       "https://<<lodox-github()>>/blob/{version}/{filepath}#L{line}"}]}]}]}.
#+END_SRC
** Profiles
#+NAME: profiles
#+BEGIN_SRC erlang
{profiles,
 [{test, [<<test-erl_opts>>,
          {deps,
           [<<ltest>>,
            <<proper>>]}]}]}.
#+END_SRC

#+NAME: test-erl_opts
#+BEGIN_SRC erlang
{erl_opts, [{src_dirs, ["src", "test"]}]}
#+END_SRC

* Modules
  :PROPERTIES:
  :noweb:    yes
  :END:
** lodox
   :PROPERTIES:
   :tangle:   ../src/lodox.lfe
   :padline:  yes
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox
  (doc "The Lodox [Rebar3][1] [provider][2].

[1]: http://www.rebar3.org/docs/plugins
[2]: https://github.com/tsloughter/providers")
  (behaviour provider)
  ;; N.B. Export all since LFE doesn't like us defining do/1.
  (export all))
#+END_SRC
*** Provider Interface
[[http://www.rebar3.org/v3.0/docs/plugins#section-provider-interface][Documentation]]
- /namespace/: in which the provider is registered.
  In this case, use ~default~, which is the main namespace.
#+BEGIN_SRC lfe
(defun namespace ()
  "The namespace in which `lodox` is registered, `default`."
  'lfe)
#+END_SRC

- /name/: The 'user friendly' name of the task.
#+BEGIN_SRC lfe
(defun provider-name ()
  "The 'user friendly' name of the task, `lodox`."
  'lodox)
#+END_SRC

- /short​_desc/: A one line, short description of the task, used in lists of
  providers.
#+BEGIN_SRC lfe
(defun short-desc ()
  "A one line, short description of the task, used in lists of providers."
  "Generate documentation from LFE source files.")
#+END_SRC

- /deps/: The list of dependencies, providers, that need to run before this
  one. You do not need to include the dependencies of your dependencies.
#+BEGIN_SRC lfe
(defun deps ()
  "The list of dependencies, providers, that need to run before this one."
  '[#(default app_discovery)])
#+END_SRC

- /desc/: The description for the task, used by ~rebar3 help~.
#+BEGIN_SRC lfe
(defun desc ()
  "The description for the task, used by `rebar3 help`."
  (short-desc))
#+END_SRC

#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; API
;;;===================================================================
#+END_SRC

~init/1~ is called when ~rebar3~ first boots and simply initiates the provider
and sets up the state.
#+BEGIN_SRC lfe
(defun init (state)
  "Initiate the Lodox provider."
  (rebar_api:debug "Initializing {~p, ~p}" `[,(namespace) ,(provider-name)])
  (let* ((opts `[#(name       ,(provider-name))   ; The 'user friendly' name
                 #(module     ,(MODULE))          ; The module implementation
                 #(namespace  ,(namespace))       ; Plugin namespace
                 #(opts       [])                 ; List of plugin options
                 #(deps       ,(deps))            ; The list of dependencies
                 #(example    "rebar3 lfe lodox") ; How to use the plugin
                 #(short_desc ,(short-desc))      ; A one-line description
                 #(desc       ,(desc))            ; A longer description
                 #(bare       true)               ; Task can be run by user
                 <<init-profiles>>])
         (provider (providers:create opts)))
    (let ((state* (rebar_state:add_provider state provider)))
      (rebar_api:debug "Initialized lodox" [])
      `#(ok ,state*))))
#+END_SRC

Per [[https://github.com/tsloughter][Tristan]]'s [[https://twitter.com/t_sloughter/status/713457165525094400][advice]], specify that Lodox should use the ~doc~ profile.
#+NAME: init-profiles
#+BEGIN_SRC lfe :tangle no
#(profiles   [doc])
#+END_SRC
See also: [[https://www.rebar3.org/docs/plugins#section-provider-interface][Provider Interface documentation]]

~do/1~ parses the rebar state for the ~current_app~ (as a singleton list) or the
list of ~project_apps~ and calls ~write-docs/1~ on each one. This is where the
actual work happens.
#+BEGIN_SRC lfe
(defun do (state)
  "Generate documentation for each application in the project.

See: [[lodox-html-writer:write-docs/2]]"
  (rebar_api:debug "Starting do/1 for lodox" [])
  (let ((apps (rebar_state:project_apps state)))
    (lists:foreach #'write-docs/1 apps))
  `#(ok ,state))
#+END_SRC

~format_error/1~ prints errors when they happen. The point is to enable
filtering of sensitive elements from the state, but in this case, it simply
prints the ~reason~.
#+BEGIN_SRC lfe
(defun format_error (reason)
  "When an exception is raised or a value returned as
`#(error #((MODULE) reason)`, `(format_error reason)` will be called
so a string can be formatted explaining the issue."
  (io_lib:format "~p" `[,reason]))
#+END_SRC

*** Internal Functions
#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; Internal functions
;;;===================================================================
#+END_SRC

~write-docs/1~ takes an ~app_info_t~ (see: [[https://github.com/rebar/rebar3/blob/master/src/rebar_app_info.erl][rebar​_app​_info.erl]]) and generates
documentation for it.
#+BEGIN_SRC lfe
(defun write-docs (app-info)
  "Given an [app_info_t], call [[lodox-html-writer:write-docs/2]] appropriately.

[app_info_t]: https://github.com/rebar/rebar3/blob/master/src/rebar_app_info.erl"
  (let* ((`[,opts ,app-dir ,name ,vsn ,out-dir]
          (lists:map (lambda (f) (call 'rebar_app_info f app-info))
            '[opts dir name original_vsn out_dir]))
         (lodox-opts (get-lodox-opts name opts))
         (ebin-dir   (filename:join out-dir "ebin"))
         (doc-dir    (filename:join app-dir "doc")))
    (rebar_api:debug "Adding ~p to the code path" `[,ebin-dir])
    (code:add_patha ebin-dir)
    (let ((project (lists:foldl
                     (lambda (m acc) (maps:merge acc m))
                     (lodox-parse:docs name)
                     `[#m(output-path ,doc-dir app-dir ,app-dir) ,lodox-opts])))
      (rebar_api:debug "Generating docs for ~p" `[,(mref project 'name)])
      (lodox-html-writer:write-docs project)
      (generated name vsn (mref project 'output-path)))))
#+END_SRC

~generated/3~ takes an app ~name~, ~vsn~ and output directory and prints a line
describing the docs that were generated.
#+BEGIN_SRC lfe
(defun generated
  "Print a string of the form:

> Generated {{app-name}} v{{version}} docs in {{output directory}}"
  ([name `#(cmd ,cmd) doc-dir]
   (generated name (os:cmd (++ cmd " | tr -d \"\\n\"")) doc-dir))
  ([name vsn doc-dir]
   (rebar_api:console "Generated ~s v~s docs in ~s" `[,name ,vsn ,doc-dir])))
#+END_SRC

TODO: describe ~get-lodox-opts/2~ here and document it in the README.
#+BEGIN_SRC lfe
(defun get-lodox-opts
  "Parse rebar.config for Lodox options.
If `name` is a binary, convert it to an atom first."
  ([name rebar-opts] (when (is_binary name))
   (get-lodox-opts (binary_to_atom name 'latin1) rebar-opts))
  ([app rebar-opts] (when (is_atom app))
   (let* ((lodox-config (if (dict:is_key 'lodox rebar-opts)
                          (dict:fetch 'lodox rebar-opts)
                          []))
          (lodox-apps   (proplists:get_value 'apps lodox-config [])))
     (maps:from_list (proplists:get_value app lodox-apps [])))))
#+END_SRC

** lodox-html-writer
   :PROPERTIES:
   :tangle:   ../src/lodox-html-writer.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-html-writer.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox-html-writer
  (doc "Documentation writer that outputs HTML.")
  (export (write-docs 1))
  (import (from levaindoc (markdown_github->html 1 ))))

(include-lib "clj/include/compose.lfe")

(include-lib "exemplar/include/html-macros.lfe")

(include-lib "lodox/include/lodox-macros.lfe")

(defun write-docs (project)
  "Take raw documentation info and turn it into formatted HTML.
Write to and return `output-path` in `opts`. Default: `\"doc\"`

N.B. [[write-docs/1]] makes great use of [[doto/255]] under the hood."
  (let* ((`#(ok ,cwd) (file:get_cwd))
         (output-path (maps:get 'output-path project "doc"))
         (app-dir     (maps:get 'app-dir project cwd))
         (project*    (-> project
                          (mset 'app-dir app-dir)
                          (mset 'modules
                                (let ((excluded-modules
                                       (maps:get 'excluded-modules project [])))
                                  (lists:foldl
                                    (match-lambda
                                      ([(= `#m(name ,name) module) acc]
                                       (if (lists:member name excluded-modules)
                                         acc
                                         (cons module acc))))
                                    [] (mref project 'modules)))))))
    (doto output-path
          (ensure-dirs '["css" "js"])
          (copy-resource "css/default.css")
          (copy-resource "css/hk-pyg.css")
          (copy-resource "js/jquery.min.js")
          (copy-resource "js/page_effects.js")
          (write-index        project*)
          (write-modules      project*)
          (write-libs         project*)
          (write-undocumented project*))))

(defun include-css (style)
  (link `[type "text/css" href ,style rel "stylesheet"]))

(defun include-js (script)
  (script `[type "text/javascript" src ,script]))

(defun link-to (uri content)
  "```html
<a href=\"{{uri}}\">{{content}}</a>
```"
  (a `[href ,uri] content))

(defun func-id
  ([func] (when (is_map func))
   (func-id (func-name func)))
  ([fname] (when (is_list fname))
   (-> (http_uri:encode (h fname))
       (re:replace "%" "." '[global #(return list)])
       (->> (++ "func-")))))

(defun format-docstring (project m) (format-docstring project [] m))

(defun format-docstring (project module func)
  (format-docstring project module func (maps:get 'format func 'markdown)))

(defun format-docstring
  ([_project _mod (map 'doc "") _format]   "")
  ([_project _mod `#m(doc ,doc) 'plaintext] (pre '[class "plaintext"] (h doc)))
  ([project mod `#m(doc ,doc) 'markdown] (when (is_map mod))
   (let ((name (maps:get 'name mod 'undefined))
         (html (markdown->html (unicode:characters_to_list doc))))
     (format-wikilinks project html name)))
  ([project mod `#m(name ,name doc ,doc) 'markdown]
   (let ((html (markdown->html (unicode:characters_to_list doc))))
     (format-wikilinks project html name))))

(defun markdown->html (markdown)
  "Given a Markdown string, convert it to HTML.
Use [pandoc] if available, otherwise [erlmarkdown].

[pandoc]: http://pandoc.org
[erlmarkdown]: https://github.com/erlware/erlmarkdown"
  (case (os:find_executable "pandoc")
    ('false (markdown:conv_utf8 markdown))
    (pandoc (let ((`#(ok ,html) (markdown_github->html markdown))) html))))

(defun format-wikilinks
  ([`#m(libs ,libs modules ,modules) html init]
   (case (re:run html "\\[\\[([^\\[]+/\\d+)\\]\\]"
                 '[global #(capture all_but_first)])
     ('nomatch html)
     (`#(match ,matches)
      (let ((to-search (++ modules libs)))
        (-> (match-lambda
              ([`#(,start ,length)]
               (let* ((match (lists:sublist html (+ 1 start) length))
                      (mfa   (lodox-util:search-funcs to-search match init)))
                 (iff (=/= mfa 'undefined)
                   (let ((`#(,mod [,_ . ,fname])
                          (lists:splitwith (lambda (c) (=/= c #\:)) mfa)))
                     `#(true #(,(re-escape (++ "[[" match "]]"))
                               ,(link-to (func-uri mod fname)
                                  (if (=:= (atom_to_list init) mod)
                                    (h fname)
                                    (h (++ mod ":" fname)))))))))))
            (lists:filtermap (lists:flatten matches))
            (->> (fold-replace html))))))))

(defun index-by (k ms) (lists:foldl (lambda (m mm) (mset mm (mref m k) m)) (map) ms))

(defun mod-filename
  ([mod] (when (is_map mod))
   (mod-filename (mod-name mod)))
  ([mname] (when (is_list mname))
   (++ mname ".html")))

(defun mod-filepath (output-dir module)
  (filename:join output-dir (mod-filename module)))

(defun mod-name (mod) (atom_to_list (mref mod 'name)))

(defun doc-filename (doc)
  (++ (mref doc 'name) ".html"))

(defun doc-filepath (output-dir doc)
  (filename:join output-dir (doc-filename doc)))

(defun func-uri (module func)
  (++ (mod-filename module) "#" (func-id func)))

(defun func-source-uri (source-uri project module func)
  (let* ((offset   (+ 1 (length (mref project 'app-dir))))
         (filepath (lists:nthtail offset (mref module 'filepath)))
         (line     (integer_to_list (mref func 'line)))
         (version  (mref project 'version)))
    (fold-replace source-uri
      `[#("{filepath}"  ,filepath)
        #("{line}"      ,line)
        #("{version}"   ,version)])))

(defun index-link (project on-index?)
  `[,(h3 '[class "no-link"] (span '[class "inner"] "Application"))
    ,(ul '[class "index-link"]
         (li `[class ,(++ "depth-1" (if on-index? " current" ""))]
             (link-to "index.html" (div '[class "inner"] "Index"))))])

(defun includes-menu
  ([`#m(libs ,libs) current-lib]
   (make-menu "Includes" libs current-lib)))

(defun modules-menu
  ([`#m(modules ,modules) current-mod]
   (make-menu "Modules" modules current-mod)))

(defun make-menu
  ([_heading [] _current] [])
  ([heading maps current]
   (flet ((menu-item
           ([`#(,name ,m)]
            (let ((class (++ "depth-1" (if (=:= m current) " current" "")))
                  (inner (div '[class "inner"] (h (atom_to_list name)))))
              (li `[class ,class] (link-to (mod-filename m) inner))))))
     `[,(h3 '[class "no-link"] (span '[class "inner"] heading))
       ,(ul (lists:map #'menu-item/1 (maps:to_list (index-by 'name maps))))])))

(defun primary-sidebar (project) (primary-sidebar project []))

(defun primary-sidebar (project current)
  (div '[class "sidebar primary"]
    `[,(index-link project (lodox-p:null? current))
      ,(includes-menu project current)
      ,(modules-menu project current)]))

(defun sorted-exported-funcs (module)
  (lists:sort
    (lambda (a b)
      (=< (string:to_lower (func-name a))
          (string:to_lower (func-name b))))
    (mref module 'exports)))

(defun funcs-sidebar (module)
  (div '[class "sidebar secondary"]
    `[,(h3 (link-to "#top" (span '[class "inner"] "Exports")))
      ,(ul
         (lists:map
           (lambda (func)
             (li '[class "depth-1"]
                 (link-to (func-uri module func)
                   (div '[class "inner"]
                     (span (h (func-name func))))))) ; TODO: members?
           (sorted-exported-funcs module)))]))

(defun default-includes ()
  `[,(meta '[charset "UTF-8"])
    ,(include-css "css/default.css")
    ,(include-css "css/hk-pyg.css")
    ,(include-js "js/jquery.min.js")
    ,(include-js "js/page_effects.js")])

(defun project-title (project)
  (span '[class "project-title"]
    `[,(span '[class "project-name"]    (h (mref project 'name))) " "
      ,(span '[class "project-version"] (h (mref project 'version)))]))

(defun header* (project)
  (div '[id "header"]
    `[,(h2 `["Generated by "
             ,(link-to "https://github.com/quasiquoting/lodox" "Lodox")])
      ,(h1 (link-to "index.html"
             `[,(project-title project) " "
               ,(span '[class "project-documented"]
                  (io_lib:format "(~w% documented)"
                    `[,(-> (mref project 'documented)
                           (mref 'percentage)
                           (round))]))]))]))

(defun index-page (project)
  (html
    `[,(head
         `[,(default-includes)
           ,(title (++ (h (mref project 'name)) " "
                       (h (mref project 'version))))])
      ,(body
         `[,(header* project)
           ,(primary-sidebar project)
           ,(div '[id "content" class "module-index"]
              `[,(h1 (project-title project))
                ,(case (mref project 'description)
                   ("" "")
                   (doc (div '[class "doc"] (p (h doc)))))
                ,(case (lists:sort
                         (lambda (a b) (=< (mod-name a) (mod-name b)))
                         (mref project 'libs))
                   ([] "")
                   (libs
                    `[,(h2 "Includes")
                      ,(lists:map
                         (lambda (lib)
                           (div '[class "module"]
                             `[,(h3 (link-to (mod-filename lib)
                                      (h (mod-name lib))))
                               ,(div '[class "index"]
                                  `[,(p "Definitions")
                                    ,(unordered-list
                                      (lists:map
                                        (lambda (func)
                                          `[" "
                                            ,(link-to (func-uri lib func)
                                               (func-name func))
                                            " "])
                                        (sorted-exported-funcs lib)))])]))
                         libs)]))
                ,(h2 "Modules")
                ,(lists:map
                   (lambda (module)
                     (div '[class "module"]
                       `[,(h3 (link-to (mod-filename module)
                                (h (mod-name module))))
                         ,(case (format-docstring project [] module)
                            (""  "")
                            ;; TODO: summarize
                            (doc (div '[class "doc"] doc)))
                         ,(div '[class "index"]
                            `[,(p "Exports")
                              ,(unordered-list
                                (lists:map
                                  (lambda (func)
                                    `[" "
                                      ,(link-to (func-uri module func)
                                         (func-name func))
                                      " "])
                                  (sorted-exported-funcs module)))])]))
                   (lists:sort
                     (lambda (a b) (=< (mod-name a) (mod-name b)))
                     (mref project 'modules)))])])]))

;; TODO: exemplar-ify this
(defun unordered-list (lst) (ul (lists:map #'li/1 lst)))

#|
(defun format-document
  ([project (= doc `#m(format ,format))] (when (=:= format 'markdown))
   ;; TODO: render markdown
   `[div (class "markdown") ,(mref doc 'content)]))

(defun document-page (project doc)
  (html
    (head
      `[,(default-includes)
        ,(title (h (mref doc 'title)))])
    (body
      `[,(header* project)
        ,(primary-sidebar project doc)
        ,(div '[id "content" class "document"]
           (div '[id "doc"] (format-document project doc)))])))
|#

(defun func-usage (func)
  (lists:map
    (lambda (pattern)
      (re:replace (lfe_io_pretty:term pattern) "comma " ". ,"
                  '[global #(return list)]))
    (mref func 'patterns)))

(defun mod-behaviour (mod)
  (lists:map
    (lambda (behaviour)
      (h4 '[class "behaviour"] (atom_to_list behaviour)))
    (mref mod 'behaviour)))

(defun func-docs (project module func)
  (div `[class "public anchor" id ,(h (func-id func))]
    `[,(h3 (h (func-name func)))
      ,(case (func-usage func)
         ('["()"] [])
         (usages
          (div '[class "usage"]
            (-> `["```commonlisp"
                  ,@(lists:map #'unicode:characters_to_list/1 usages)
                  "```"]
                (string:join "\n")
                (markdown->html)))))
      ,(div '[class "doc"]
         (format-docstring project module func))
      ;; TODO: members?
      ,(case (maps:get 'source-uri project 'undefined)
         ('undefined [])                ; Log failure to generate link?
         (source-uri
          (div '[class "src-link"]
            (link-to (func-source-uri source-uri project module func)
              "view source"))))]))

(defun module-page (project module)
  (html
    `[,(head
         `[,(default-includes)
           ,(title (++ (h (mod-name module)) " documentation"))])
      ,(body
         `[,(header* project)
           ,(primary-sidebar project module)
           ,(funcs-sidebar module)
           ,(div '[id "content" class "module-docs"]
              `[,(h1 '[id "top" class "anchor"] (h (mod-name module)))
                ,(mod-behaviour module)
                ,(div '[class "doc"] (format-docstring project [] module))
                ,(lists:map (lambda (func) (func-docs project module func))
                   (sorted-exported-funcs module))])])]))

(defun lib-page (project lib)
  (html
    `[,(head
         `[,(default-includes)
           ,(title (++ (h (mref lib 'name)) " documentation"))])
      ,(body
         `[,(header* project)
           ,(primary-sidebar project lib)
           ,(funcs-sidebar lib)
           ,(div '[id "content" class "module-docs"] ; TODO: confirm this
              `[,(h1 '[id "top" class "anchor"] (h (mref lib 'name)))
                ,(lists:map (lambda (func) (func-docs project lib func))
                   (sorted-exported-funcs lib))])])]))

(defun copy-resource (output-dir resource)
  (let* ((this  (proplists:get_value 'source (module_info 'compile)))
         (lodox (filename:dirname (filename:dirname this))))
    (file:copy (filename:join `[,lodox "resources" ,resource])
               (filename:join output-dir resource))))

(defun ensure-dirs
  "Given a `path` and list of `dirs`, call [[ensure-dir/2]] `path` `dir`
for each `dir` in `dirs`."
  ([path `(,dir . ,dirs)]
   (ensure-dir path dir)
   (ensure-dirs path dirs))
  ([path ()] 'ok))

(defun ensure-dir (dir)
  "Given a `dir`ectory path, perform the equivalent of `mkdir -p`.
If something goes wrong, throw a descriptive error."
  (case (filelib:ensure_dir (filename:join dir "dummy"))
    ('ok               'ok)
    (`#(error ,reason) (error reason))))

(defun ensure-dir (path dir)
  "Given a `path` and `dir`ectory name, call [[ensure-dir/1]] on `path`/`dir`."
  (ensure-dir (filename:join path dir)))

(defun write-index (output-dir project)
  (file:write_file (filename:join output-dir "index.html")
                   (index-page project)))

(defun write-modules (output-dir project)
  (flet ((write-module (module)
           (-> (mod-filepath output-dir module)
               (file:write_file (module-page project module)))))
    (lists:foreach #'write-module/1 (mref project 'modules))))

(defun write-libs (output-dir project)
  (flet ((write-lib (lib)
           (file:write_file (mod-filepath output-dir lib)
                            (lib-page project lib))))
    (lists:foreach #'write-lib/1 (mref project 'libs))))

(defun write-undocumented
  ([output-dir `#m(documented #m(undocumented ,undocumented))]
   (-> (maps:fold
         (lambda (k v acc)
           (-> (io_lib:format "== ~s ==~n~s~n" `[,k ,(string:join v "\n")])
               (cons acc)))
         "" undocumented)
       (string:join "\n")
       (->> (file:write_file (filename:join output-dir "undocumented.txt"))))))

#|
(defun write-documents (output-dir project)
  (flet ((write-document (document)
           (-> (doc-filepath output-dir document)
               (file:write_file (document-page project document)))))
    (lists:foreach #'write-document/1 (mref project 'documents))))
|#

(defun func-name (func)
  (++ (h (mref func 'name)) "/" (integer_to_list (mref func 'arity))))

(defun h (text)
  "Convenient alias for escape-html/1."
  (escape-html text))

(defun escape-html
  "Change special characters into HTML character entities."
  ([x] (when (is_atom x))
   (escape-html (atom_to_list x)))
  ([text]
   (fold-replace text
     '[#("\\&"  "\\&amp;")
       #("<"  "\\&lt;")
       ;; #(">"  "\\&gt;")
       #("\"" "\\&quot;")
       #("'"  "\\&apos;")])))

;; TODO: remove this unless we actually need it.
#|
(defun escape (string)
  "Given a string, return a copy with backticks and double quotes escaped."
  (re:replace string "[`\"]" "\\\\&" '[global #(return list)]))
|#

(defun fold-replace (string pairs)
  (-> (match-lambda
        ([`#(,patt ,replacement) acc]
         (re:replace acc patt replacement '[global #(return list)])))
      (lists:foldl string pairs)))

;; Stolen from Elixir
;; https://github.com/elixir-lang/elixir/blob/944990381f6cadbaf751f2443d485684ba35b6d8/lib/elixir/lib/regex.ex#L601-L619
(defun re-escape (string)
  (re:replace string "[.^$*+?()[{\\\|\s#]" "\\\\&" '[global  #(return list)]))
#+END_SRC

** lodox-parse
   :PROPERTIES:
   :tangle:   ../src/lodox-parse.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-parse.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox-parse
  (doc "Parsing LFE source files for metadata.")
  (export (docs 1)
          (form-doc 1)
          (macro-doc 1)
          (lib-docs 0) (lib-docs 1) (lib-doc 1)
          (script-doc 1)
          (documented 1))
  (import (from lodox-p
            (arglist? 1) (arg? 1)
            (macro-clauses? 1) (macro-clause? 1)
            (clauses? 1) (clause? 1)
            (string? 1)
            (null? 1))))

(include-lib "clj/include/compose.lfe")

(include-lib "lodox/include/lodox-macros.lfe")


;;;===================================================================
;;; API
;;;===================================================================

;; TODO: write a better docstring
(defun docs (app-name)
  "Given an app-name (binary), return a map like:

```commonlisp
'#m(name        #\"lodox\"
    version     \"<<lodox-version()>>\"
    description \"The LFE rebar3 Lodox plugin\"
    documents   ()
    modules     {{list of maps of module metadata}}
    documented  #m(modules    {{map from module name to list of f/a strings}}
                   percentage {{percent documented (float)}}))
```"
  (let* ((app         (doto (binary_to_atom app-name 'latin1)
                            (application:load)))
         (app-info    (let ((`#(ok ,info) (application:get_all_key app)))
                        (maps:from_list info)))
         (modules     (mod-docs (mref app-info 'modules)))
         (version     (maps:get 'vsn         app-info ""))
         (documented  (documented modules))
         (description (maps:get 'description app-info ""))
         (libs        (lib-docs)))
    `#m(name        ,app-name
        version     ,version
        description ,description
        libs        ,libs
        modules     ,modules
        documented  ,documented)))

(defun form-doc
  ;; (defun name clause)
  ([(= `(defun ,name ,(= `[,arglist . ,_body] clause)) shape)]
   (when (is_atom name) (is_list arglist))
   (if (clause? clause)
     (ok-form-doc name (length arglist) `[,(pattern clause)] "")
     (unhandled-shape! shape)))

  ;; (defun name () form)
  ([`(defun ,name () ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] ""))

  ;; (defun name <doc|clause> clause)
  ;; (defun name arglist      form)
  ([`(defun ,name . ,(= `[,x ,y] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) ""))
    ((andalso (string? x) (clause? y))
     (ok-form-doc name (length (car y)) `[,(pattern y)] x))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] ""))))

  ;; (defun name doc clause)
  ([(= `(defun ,name ,doc-string ,(= `[,arglist . ,_body] clause)) shape)]
   (when (is_atom name) (is_list doc-string) (is_list arglist))
   (if (andalso (clause? clause) (string? doc-string))
     (ok-form-doc name (length arglist) `[,(pattern clause)] doc-string)
     (unhandled-shape! shape)))

  ;; (defun name () <doc|form> form)
  ([`(defun ,name () ,maybe-doc ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] (if (string? maybe-doc) maybe-doc "")))

  ;; (defun name "" clause clause ...?)
  ;; (defun name () doc    form   ...?)
  ([`(defun ,name () . ,(= `[,x . ,_] rest))]
   (if (clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) "")
     (ok-form-doc name 0 '[()] (if (string? x) x ""))))

  ;; (defun name <doc|clause> clause     ...)
  ;; (defun name arglist      <doc|form> ...)
  ([`(defun ,name ,x . ,(= `[,y . ,_] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (if (clause? x)
       (ok-form-doc name (length (car x)) (patterns `(,x . ,rest)) "")
       (ok-form-doc name (length (car y))
                    (patterns rest)
                    (if (string? x) x ""))))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] (if (string? y) y "")))))

  ;; (defun ...)
  ([(= `(defun . ,_) shape)]
   (unhandled-shape! shape))

  ;; (defmacro ...)
  ([(= `(defmacro . ,_) form)]
   (macro-doc form))

  ;; This pattern matches non-def{un,macro} forms.
  ([_] 'undefined))

(defun form-doc (form line)
  "Equivalent to [[form-doc/3]] with `[]` as `exports`."
  (form-doc form line []))

(defun form-doc (form line exports)
  (case (form-doc form)
    (`#(ok ,(= `#m(name ,f arity ,a) doc))
     (iff (orelse (null? exports) (lists:member `#(,f ,a) exports))
       `#(true ,(mset doc 'line line))))
    ('undefined 'false)))

(defun macro-doc
  ;; (defmacro name clause)
  ([(= `(defmacro ,name ,clause) shape)]
   (when (is_atom name))
   (if (macro-clause? clause)
     (let ((arity (if (clause? clause) (length (car clause)) 255)))
       (ok-form-doc name arity `[,(pattern clause)] ""))
     (unhandled-shape! shape)))

  ;; (defmacro name () form)
  ([`(defmacro ,name () ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] ""))

  ;; (defmacro name <doc|clause> clause)
  ;; (defmacro name arglist      form)
  ;; (defmacro name varargs      form)
  ([`(defmacro ,name . ,(= `[,x ,y] rest))]
   (when (is_atom name))
   (cond
    ((andalso (string? x) (macro-clause? y))
     (if (clause? x)
       (ok-form-doc name (length (car y)) `[,(pattern y)] x)
       (ok-form-doc name 255 `[,(pattern y)] x)))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] ""))
    ((macro-clauses? rest)
     (if (clause? x)
       (ok-form-doc name (length (car x)) (patterns rest) "")
       (ok-form-doc name 255 (patterns rest) "")))
    ((arg? x)
     (ok-form-doc name 255 `[(,x ...)] ""))))

  ;; (defmacro name doc clause)
  ([(= `(defmacro ,name ,doc-string ,(= `[,arglist . ,_body] clause)) shape)]
   (when (is_atom name) (is_list doc-string) (is_list arglist))
   (if (andalso (macro-clause? clause) (string? doc-string))
     (let ((arity (if (clause? clause) (length arglist) 255)))
       (ok-form-doc name arity `[,(pattern clause)] doc-string))
     (unhandled-shape! shape)))

  ;; (defmacro name () <doc|form> form)
  ([`(defmacro ,name () ,maybe-doc ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] (if (string? maybe-doc) maybe-doc "")))

  ;; (defmacro name "" clause clause ...?)
  ;; (defmacro name () doc    form   ...?)
  ([(= `(defmacro ,name () . ,(= `[,x . ,_] rest)) shape)]
   (if (macro-clauses? rest)
     (let ((arity (if (clause? x) (length x) 255)))
       (ok-form-doc name arity (patterns rest) ""))
     (ok-form-doc name 0 '[()] (if (string? x) x ""))))

  ;; (defmacro name <doc|clause> clause ...)
  ;; (defmacro name arglist      <doc|form> ...)
  ([(= `(defmacro ,name ,x . ,(= `[,y . ,_] rest)) shape)]
   (when (is_atom name))
   (cond
    ((andalso (not (string? x)) (arglist? x))
     (ok-form-doc name (length x) `[,x] (if (string? y) y "")))
    ((macro-clauses? rest)
     (cond
      ((andalso (not (string? x)) (macro-clause? x))
       (let ((arity (if (clause? x) (length (car x)) 255)))
         (ok-form-doc name arity (patterns `(,x . ,rest)) "")))
      ((macro-clause? x)
       (let ((arity (if (clause? x) (length (car x)) 255)))
         (ok-form-doc name arity (patterns rest) (if (string? x) x ""))))
      ('true
       (let ((arity (if (clause? y) (length (car y)) 255)))
         (ok-form-doc name arity (patterns rest) (if (string? x) x ""))))))
    ((arg? x)
     (ok-form-doc name 255 `[(,x ...)] ""))))

  ;; (defmacro ...)
  ([(= `(defmacro . ,_) shape)]
   (unhandled-shape! shape))

  ;; This pattern matches non-defmacro forms.
  ([_] 'undefined))

(defun ok-form-doc (name arity patterns doc)
  `#(ok #m(name ,name arity ,arity patterns ,patterns doc ,doc)))

(defun unhandled-shape! (shape)
  "Throw an error with `shape` pretty printed."
  (error (lists:flatten
          (io_lib:format "Unhandled shape: ~s~n"
            `[,(re:replace (lfe_io_pretty:term shape) "comma " ". ,"
                           '[global #(return list)])]))))

(defun lib-docs ()
  "Call [[lib-docs/1]] on each LFE file in `./include`."
  (lib-docs (filelib:wildcard (filename:absname "include/*.lfe"))))

(defun lib-docs (files)
  "Call [[lib-doc/1]] on each file in `files` and
return the list of non-empty results."
  (lists:filtermap #'lib-doc/1 files))

(defun lib-doc (filename)
  "Parse `filename` and attempt to return a tuple, `` `#(true ,defsmap) ``
where `defsmap` is a map representing the definitions in `filename`.
If `file-doc/1` returns the empty list, return `false`."
  (case (filename:extension filename)
    (".lfe" (case (file-doc filename)
              ('()     'false)
              (exports `#(true #m(name      ,(-> filename
                                                 (filename:basename ".lfe")
                                                 (list_to_atom))
                                  behaviour ""
                                  doc       ""
                                  exports   ,exports
                                  ;; dirty hack
                                  filepath  ,filename)))))
    (_      'false)))

(defun script-doc (filename)
  (if (filelib:is_file filename)
    (let* ((`#(ok ,file) (file:open filename '[read]))
           (tmp (drop-shebang filename file))
           (doc (file-doc tmp)))
      (file:delete tmp)
      doc)
    '()))

(defun documented (modules)
  "Given a list of parsed modules, return a map representing undocumented
functions therein.

```commonlisp
(map 'percentage   {{float 0.0-100.0}}
     'undocumented (map {{module name (atom) }} [\"{{function/arity}}\" ...]
                        ...))
```"
  (flet ((percentage
           ([`#(#(,n ,d) ,modules)]
            (->> `[,(* (/ n d) 100)]
                 (io_lib:format "~.2f")
                 (clj-comp:compose #'list_to_float/1 #'hd/1)
                 (mset `#m(undocumented ,modules) 'percentage)))))
    (->> modules
         (lists:foldl #'documented/2 #(#(0 0) #m()))
         (percentage))))

(defun documented
  ([`#m(exports ,exports name ,name) acc]
   (fletrec ((tally
               ([(= (map 'doc "") export) `#(#(,n ,d) ,m)]
                `#(#(,n ,(+ d 1))
                   ,(-> (func-name export)
                        (cons (maps:get name m []))
                        (->> (mset m name)))))
               ([`#m(doc ,_) `#(#(,n ,d) ,m)]
                `#(#(,(+ n 1) ,(+ d 1)) ,m))))
     (lists:foldl #'tally/2 acc exports))))


;;;===================================================================
;;; Internal functions
;;;===================================================================

(defun mod-behaviour (module)
  (let ((attributes (call module 'module_info 'attributes)))
    (proplists:get_value 'behaviour attributes '())))

(defun mod-docs
  ([mods] (when (is_list mods))
   (lists:filtermap #'mod-docs/1 mods))
  ([mod]  (when (is_atom mod))
   (let ((file (proplists:get_value 'source (call mod 'module_info 'compile))))
     (case (filename:extension file)
       (".lfe" (case (mod-docs file (call mod 'module_info 'exports))
                 ('()     'false)
                 (exports `#(true #m(name      ,(mod-name mod)
                                     behaviour ,(mod-behaviour mod)
                                     doc       ,(mod-doc mod)
                                     exports   ,exports
                                     ;; dirty hack
                                     filepath  ,file)))))
       (_      'false)))))

(defun mod-docs (file exports)
  (if (filelib:is_file file)
    (let ((`#(ok ,forms) (lfe_io:parse_file file)))
      (lists:filtermap
        (match-lambda ([`#(,form ,line)] (form-doc form line exports)))
        forms))
    '()))

(defun mod-doc
  ([module] (when (is_atom module))
   (let ((attributes (call module 'module_info 'attributes)))
     (proplists:get_value 'doc attributes ""))))

(defun mod-name (mod) (call mod 'module_info 'module))

(defun drop-shebang (filename file)
  (let ((`#(ok [#\# #\! . ,_]) (file:read_line file))
        (tmp-file (tmp-filename filename)))
    (file:copy file tmp-file)
    tmp-file))

(defun tmp-filename (filename)
  (string:concat filename ".tmp"))

(defun file-doc (filename)
  (if (filelib:is_file filename)
    (let ((`#(ok ,forms) (lfe_io:parse_file filename)))
      (lists:filtermap
        (match-lambda
          ([`#(,form ,line)] (form-doc form line)))
        forms))
    '()))

(defun patterns (forms) (lists:map #'pattern/1 forms))

(defun pattern
  ([`(,patt ,(= `(when . ,_) guard) . ,_)] `(,@patt ,guard))
  ([`(,arglist . ,_)] arglist))

(defun func-name
  "Given a parsed def{un,macro} form (map), return a string, `\"name/arity\"`."
  ([`#m(name ,name arity ,arity)]
   (->> `[,name ,arity] (io_lib:format "~s/~w") (lists:flatten))))
#+END_SRC

** lodox-p
   :PROPERTIES:
   :tangle:   ../src/lodox-p.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-p.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+NAME: lodox-p
#+BEGIN_SRC lfe :padline yes
(defmodule lodox-p
  (doc "Predicates used by [lodox-parse](lodox-parse.html).")
  (export (macro-clauses? 1) (macro-clause? 1)
          (clauses? 1) (clause? 1)
          (arglist? 1) (arg? 1)
          (patterns? 1) (pattern? 1)
          (string? 1)
          (null? 1)))

(defun macro-clauses?
  "Return `true` iff `forms` is a list of elements satisfying [[macro-clause?/1]]."
  ([forms] (when (is_list forms)) (lists:all #'macro-clause?/1 forms))
  ([_]                            'false))

(defun macro-clause?
  "Given a term, return `true` iff it seems like a macro clause.
A macro clause either satisfies [[clause?/1]] without alteration or when
its head in encapsulated in a list."
  ([(= `(,h . ,t) form)]
   (orelse (clause? form)
           (clause? `([,h] . ,t))))
  ([_] 'false))

(defun clauses?
  "Return `true` iff `forms` is a list of elements satisfying [[clause?/1]]."
  ([forms] (when (is_list forms))
   (andalso (lists:all #'clause?/1 forms)
            (let ((arity (length (caar forms))))
              (lists:all (lambda (form) (=:= (length (car form)) arity)) forms))))
  ([_] 'false))

(defun clause?
  "Given a term, return `true` iff it is a list whose head satisfies [[arglist?/1]]."
  ([`(,_)]      'false)
  ([`([] . ,_)] 'false)
  ([`(,h . ,_)] (when (is_list h)) (patterns? h))
  ([_]          'false))

(defun arglist?
  "Given a term, return `true` iff it is either the empty list, a list of
elements satisfying [[arg?/1]] or a term that satisfies [[arg?/1]]."
  (['()]        'true)
  ([`(,h . ,t)] (andalso (arg? h) (if (is_list t) (arglist? t) (arg? t))))
  ([_]          'false))

(defun arg? (x)
  "Return `true` iff `x` seems like a valid element of an arglist."
  (lists:any (lambda (p) (funcall p x))
             (list #'is_atom/1
                   #'is_binary/1
                   #'is_bitstring/1
                   #'is_number/1
                   #'is_map/1
                   #'is_tuple/1
                   #'string?/1)))

(defun patterns?
    "Given a term, return `true` iff it is either the empty list, a list of
elements satisfying [[pattern?/1]] or a term that satisfies [[pattern?/1]]."
  (['()]        'true)
  ([`(,h . ,t)]
   (andalso (pattern? h) (if (is_list t) (patterns? t) (pattern? t))))
  ([_] 'false))

(defun pattern?
  "Return `true` iff `x` seems like a valid pattern or satisfies [[arg?/1]]."
  ([(= x `(,h . ,_t))]
   (orelse (string? x)
           (lists:member h
             '[= ++* () backquote quote binary cons list map tuple])
           (andalso (is_atom h) (lists:prefix "match-" (atom_to_list h)))))
  ([x] (arg? x)))

(defun string? (data)
  "Return `true` iff `data` is a flat list of printable characters."
  (io_lib:printable_list data))

(defun null?
  "Return `true` iff `data` is the empty list."
  (['()] 'true)
  ([_]   'false))
#+END_SRC

** lodox-util
   :PROPERTIES:
   :tangle:   ../src/lodox-util.lfe
   :padline:  yes
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-util.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+NAME: lodox-util
#+BEGIN_SRC lfe :padline yes
(defmodule lodox-util
  (doc "Utility functions to inspect the current version of lodox and its dependencies.")
  (export (search-funcs 2) (search-funcs 3)))

(defun search-funcs (modules partial-func)
  "Find the best-matching `def{un,macro}`.

Given a list of modules and a partial `def{un,macro}` string, return the first
matching definition. If none is found, return `` 'undefined ``.

Equivalent to [[search-funcs/3]] with `` 'undefined `` as `starting-mod`."
  (search-funcs modules partial-func 'undefined))

(defun search-funcs (modules partial-func starting-mod)
  "Like [[search-funcs/2]], but give precedence to matches in `starting-mod`."
  (let* ((suffix   (if (lists:member #\: partial-func)
                     partial-func
                     (cons #\: partial-func)))
         (matches  (lists:filter
                     (lambda (func-name) (lists:suffix suffix func-name))
                     (exported-funcs modules)))
         (external (lists:dropwhile
                     (lambda (func-name)
                       (=/= (atom_to_list starting-mod) (module func-name)))
                     matches)))
    (if (lodox-p:null? external)
      (if (lodox-p:null? matches) 'undefined (car matches))
      (car external))))
#+END_SRC
#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; Internal functions
;;;===================================================================
#+END_SRC
#+BEGIN_SRC lfe
(defun exported-funcs (modules)
  (lc ((<- mod modules)
       (<- func (mref mod 'exports)))
    (func-name mod func)))

(defun func-name (mod func)
  (++ (atom_to_list (mref mod 'name))
      ":" (atom_to_list (mref func 'name))
      "/" (integer_to_list (mref func 'arity))))

(defun module (func-name)
  (lists:takewhile (lambda (c) (=/= c #\:)) func-name))
#+END_SRC

* Macros
  :PROPERTIES:
  :noweb:    yes
  :END:
#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
<<generated()>>
#+END_SRC

Inspired by [[http://clojuredocs.org/clojure.core/doto][Clojure]], ~doto~ takes a term ~x~ and threads it through given
s-expressions as the first argument, e.g. ~(-> x (f y z))~, or functions,
e.g. ~(funcall #'g/1 x)~, evaluating them for their side effects, and then
returns ~x~.
#+BEGIN_SRC lfe
(defmacro doto
  <<doto>>)
#+END_SRC

Also known as ~when~ in other languages, ~iff~ takes a ~test~ that returns a
boolean and a ~then~ branch of an ~if~ expression, and returns ~then~ iff
~test~, otherwise ~false~.

N.B. ~iff~ cannot be called ~when~ in LFE, since ~when~ is reserved for guards.

#+BEGIN_SRC lfe
(defmacro iff (test then) <<iff>>)
#+END_SRC

#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
(defmacro doto
  "Evaluate all given s-expressions and functions in order,
for their side effects, with the value of `x` as the first argument
and return `x`."
  <<doto>>)
#+END_SRC
#+NAME: doto
#+BEGIN_SRC lfe :exports none
(`(,x . ,sexps)
 `(let ((,'x* ,x))
    ,@(lists:map
        (match-lambda
          ([`(,f . ,args)] `(,f ,'x* ,@args))
          ([f]             `(,f ,'x*)))
        sexps)
    ,'x*))
#+END_SRC

#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
(defmacro iff (test then)
  "Given a `test` that returns a boolean, if `test` is `true`, return `then`,
  otherwise `false`."
  <<iff>>)
#+END_SRC
#+NAME: iff
#+BEGIN_SRC lfe :exports none
`(if ,test ,then)
#+END_SRC

* Tests
  :PROPERTIES:
  :noweb:    yes
  :END:
** Property Tests
   :PROPERTIES:
   :tangle:   ../test/lodox_parse_tests.erl
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/test/lodox_parse_tests.erl][Source]]
#+BEGIN_SRC erlang :exports none
<<generated("erlang")>>
#+END_SRC
#+BEGIN_SRC erlang
-module(lodox_parse_tests).

-compile(export_all).

-include_lib("proper/include/proper.hrl").

-include_lib("eunit/include/eunit.hrl").

-define(TIMEOUT, 90).

-define(OPTIONS(N), [{on_output, fun pprint/2}, {numtests, N}]).


%%%===================================================================
%%% EUnit tests
%%%===================================================================

parse_test_() ->
  Properties =
    [ {"A function without a docstring produces an empty docstring.",
       prop_defun_simple(), 500}
    , {"A simple function with a docstring is correctly parsed.",
       prop_defun_simple_doc(), 500}
    , {"A function with pattern clauses produces an empty docstring.",
       prop_defun_match(), 100}
    , {"A function with pattern clauses and a docstring is correctly parsed.",
       prop_defun_match_doc(), 100}
    ],
  [{timeout, ?TIMEOUT,
    {Title, ?_assert(proper:quickcheck(Property, ?OPTIONS(NumTests)))}}
   || {Title, Property, NumTests} <- Properties].


%%%===================================================================
%%% Properties
%%%===================================================================

prop_defun_simple() ->
  ?FORALL(D, defun_simple(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(D),
            "" =:= Doc
          end).

prop_defun_simple_doc() ->
  ?FORALL(Defun, defun_simple_doc(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            lists:nth(4, Defun) =:=  Doc
          end).

prop_defun_match() ->
  ?FORALL(Defun, defun_match(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            "" =:= Doc
          end).

prop_defun_match_doc() ->
  ?FORALL(Defun, defun_match_doc(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            lists:nth(3, Defun) =:=  Doc
          end).


%%%===================================================================
%%% defun shapes
%%%===================================================================

defun_simple() ->
  [defun, atom(), arglist_simple()
   | body()].

defun_simple_doc() ->
  [defun, atom(), arglist_simple(),
   docstring()
   | body()].

defun_match() ->
  Arity = random:uniform(10),
  [defun, atom()
   | non_empty(list(pattern_clause(Arity)))].

defun_match_doc() ->
  Arity = random:uniform(10),
  [defun, atom(),
   docstring()
   | non_empty(list(pattern_clause(Arity)))].


%%%===================================================================
%%% Custom types
%%%===================================================================

%%% Functions

arglist_simple() -> list(atom()).

body() -> union([[printable_string()], [non_string_term() | list(form())]]).

form() -> union([non_string_term(), printable_string(), [atom() | list()]]).

docstring() -> printable_string().

arglist_patterns(Arity) -> vector(Arity, pattern()).


%%% Patterns

pattern() -> union([non_string_term(), printable_string(), pattern_form()]).

pattern_form() ->
  [oneof(['=', '++*', [],
          backquote, quote,
          binary, cons, list, map, tuple,
          match_fun()])
   | non_empty(list())].

%% Don't waste atoms, since we're already running out.
%% match_fun() -> ?LET(F, printable_string(), list_to_atom("match-" ++ F)).
match_fun() -> 'match-record'.

pattern_clause(Arity) ->
  [arglist_patterns(Arity) |
   [oneof([guard(), form()]) | body()]].

guard() -> ['when' | non_empty(list(union([logical_clause(), comparison()])))].


%%% Logical clauses

logical_clause() ->
  X = union([atom(), comparison()]),
  [logical_operator(), X | non_empty(list(X))].

logical_operator() -> oneof(['and', 'andalso', 'or', 'orelse']).


%%% Comparisons

comparison() -> [comparison_operator(), atom() | list(atom())].

comparison_operator() -> oneof(['==', '=:=', '=/=', '<', '>', '=<', '>=']).


%%% Strings and non-strings

non_string_term() ->
  union([atom(), number(), [], bitstring(), binary(), boolean(), tuple()]).

printable_char() -> union([integer(32, 126), integer(160, 255)]).

printable_string() -> list(printable_char()).


%%%===================================================================
%%% Internal functions
%%%===================================================================

pprint(_Format, [Defun]) when defun =:= hd(Defun) ->
  io:format(user, "~s~n", [pprint(Defun)]);
pprint(Format, Data) ->
  io:format(user, Format, Data).

pprint(Term) ->
  re:replace(lfe_io_pretty:term(Term), "comma ", ". ,",
             [global, {return, list}]).
#+END_SRC
** Unit Tests
   :PROPERTIES:
   :tangle:   ../test/unit-lodox-tests.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/test/unit-lodox-tests.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule unit-lodox-tests
  (behaviour ltest-unit)
  (export (projects_shapes_test_ 0)
          (modules_shapes_test_  0)
          (exports_shapes_test_  0)))

(include-lib "ltest/include/ltest-macros.lfe")
#+END_SRC

*** ~project~ Shapes
#+BEGIN_SRC lfe
(deftestgen projects-shapes
  (lists:zipwith #'validate_project/2 (src-dirs) (all-docs)))

;; EUnit gets very upset if the following _ is a -.
(defun validate_project (dir project)
  `[#(#"project is a map"
      ,(_assert (is_map project)))
    #(#"description is a string"
      ,(_assert (lodox-p:string? (mref* project 'description))))
    #(#"libs is a list"
      ,(_assert (is_list (mref* project 'libs))))
    #(#"modules is a list"
      ,(_assert (is_list (mref* project 'modules))))
    #(#"name matches directory"
      ,(_assertEqual (project-name dir) (mref* project 'name)))
    #(#"version is a list"
      ,(_assert (is_list (mref* project 'version))))])
#+END_SRC

*** ~modules~ Shapes
#+BEGIN_SRC lfe
(deftestgen modules-shapes
  (lists:map #'validate_module/1 (project-wide 'modules)))

(defun validate_module (module)
  `[#(#"module is a map"
      ,(_assert (is_map module)))
    #(#"module has correct keys"
      ,(_assertEqual '(behaviour doc exports filepath name) (maps:keys module)))
    #(#"behaviour is a list of atoms"
      ,(_assert (lists:all #'is_atom/1 (mref* module 'behaviour))))
    #(#"doc is a list"
      ,(_assert (is_list (mref* module 'doc))))
    #(#"exports is a list"
      ,(_assert (is_list (mref* module 'exports))))
    #(#"filepath refers to a regular file"
      ,(_assert (filelib:is_regular (mref* module 'filepath))))
    #(#"name is an atom"
      ,(_assert (is_atom (mref* module 'name))))])
#+END_SRC

*** ~exports~ Shapes
#+BEGIN_SRC lfe
(deftestgen exports-shapes
  (lists:map #'validate_exports/1 (project-wide 'exports 'modules)))

(defun validate_exports (exports)
  `[#(#"exports is a map"
      ,(_assert (is_map exports)))
    #(#"exports has correct keys"
      ,(_assertEqual '(arity doc line name patterns) (maps:keys exports)))
    #(#"patterns is a list of patterns (which may end with a guard)"
      ,(let ((patterns (lists:map
                         (lambda (pattern)
                           (if (is_list pattern)
                             (lists:filter
                               (match-lambda
                                 ([`(when . ,_t)] 'false)
                                 ([_]             'true))
                               pattern)))
                         (mref* exports 'patterns))))
         (_assert (lists:all #'lodox-p:patterns?/1 patterns))))
    #(#"artity is an integer"
      ,(_assert (is_integer (mref* exports 'arity))))
    #(#"doc is a string"
      ,(_assert (lodox-p:string? (mref* exports 'doc))))
    #(#"line is an integer"
      ,(_assert (is_integer (mref* exports 'line))))
    #(#"name is an atom"
      ,(_assert (is_atom (mref* exports 'name))))])
#+END_SRC
#+BEGIN_SRC lfe :exports none
#+END_SRC
#+BEGIN_SRC lfe :exports none :padline no
;;;===================================================================
;;; Internal functions
;;;===================================================================

(defun all-docs () (lists:map #'lodox-parse:docs/1 '(#"lodox")))

(defun mref* (m k) (maps:get k m 'error))

(defun project-name
  (["src"] #"lodox")
  ([dir]   (filename:basename (filename:dirname dir))))

(defun project-wide
  ([f]   (when (is_function f)) (lists:flatmap f (all-docs)))
  ([key]                        (project-wide (lambda (proj) (mref* proj key)))))

(defun project-wide (key2 key1)
  (project-wide
   (lambda (proj) (lists:flatmap (lambda (m) (mref* m key2)) (mref* proj key1)))))

(defun src-dirs () '("src"))
#+END_SRC

* Travis CI
  :PROPERTIES:
  :noweb:    yes
  :END:
[[https://travis-ci.org/quasiquoting/lodox][Link]]
#+BEGIN_SRC yaml :exports none :tangle ../.travis.yml
<<generated("yaml")>>
#+END_SRC
#+BEGIN_SRC yaml :padline yes :tangle ../.travis.yml
language: erlang
# http://stackoverflow.com/a/24600210/1793234
# Handle git submodules yourself
git:
  submodules: false
# Use sed to replace the SSH URL with the public URL, then initialize submodules
before_install:
  - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules
  - git submodule update --init --recursive
install: true
before_script:
    - wget https://s3.amazonaws.com/rebar3/rebar3
    - chmod 755 rebar3
script:
  - ./rebar3 as test compile
  - <<erlang-vm-tuning-hacks>>
notifications:
  email:
    - quasiquoting@gmail.com
otp_release:
  - 18.2
  - 18.0
#+END_SRC

** Erlang VM Tuning Hacks
Due to the the property-based tests generating lots and lots of atoms via
~list_to_atom/1~, it's necessary to tune the Erlang VM a bit.

Per [[http://erlang.org/doc/man/erl.html#+t][the documentation]], ~+t size~ lets you:
#+BEGIN_QUOTE
Set the maximum number of atoms the VM can handle. Default is 1048576.
#+END_QUOTE

1048576 is nowhere near enough for these particular tests,
so we set it to 10000000 instead.
#+NAME: max_atoms
#+BEGIN_SRC fish
+t 10000000
#+END_SRC

Next, we ensure all the necessary directories are on the code path:
#+NAME: code_path
#+BEGIN_SRC fish
-pa _build/test/lib/*/ebin
#+END_SRC

Then, without a shell, we run the EUnit tests with the ~verbose~ option:
#+NAME: eunit_test
#+BEGIN_SRC fish
-noshell -eval 'eunit:test({application, lodox}, [verbose]).'
#+END_SRC

Finally, we make ~init~ call ~init:stop/0~:
#+NAME: init_stop
#+BEGIN_SRC fish
-s init stop
#+END_SRC

#+NAME: erlang-vm-tuning-hacks
#+BEGIN_SRC fish :exports none
erl <<max_atoms>> <<code_path>> <<eunit_test>> <<init_stop>>
#+END_SRC

#+INCLUDE: LICENSE.org :minlevel 1
